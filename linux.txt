linux系统目录 对应的功能
linux文件系统是级层式的树状结构，linux系统：文件即系统
linux只有一个根目录 /
我登录用户是chen
cd ~
~ 代表的就是 /home/chen/
————————————————————————————————————————————————————————————————————————————
/bin 二进制可执行指令文件
/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
/srv 服务启动目录
/sys 系统
/selinux 安全子系统

/dev 管理设备，将硬件以文件方式映射
/etc 系统管理和软件配置文件
/etc/rc.d 启动的配置文件和脚本
/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序
/tmp 公用的临时文件存储点
/media 光驱，U盘挂载处
/root 系统管理员的主目录
/sbin 就是super user系统管理员目录
/opt 将安装文件放在这
/mnt 系统提供这个目录是让用户临时挂载其他的文件系统。共享文件夹
/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
/var 某些大文件的溢出区，比方说各种服务的日志文件

/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：
/usr/X11R6 存放X window的目录
/usr/bin 众多的应用程序
/usr/sbin 超级用户的一些管理程序
/usr/doc linux文档
/usr/include linux下开发和编译应用程序所需要的头文件
/usr/lib 常用的动态链接库和软件包的配置文件
/usr/man 帮助文档
/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里
/usr/local/ 编译软件存放处
/usr/local/bin 本地增加的命令
/usr/local/lib 本地增加的库
___________________________________________________________________
cat /etc/shells 查询shell版本
echo $SHELL 当前用户使用的shell
cat /etc/passwd  各个用户使用的shell

抽象的命令栏，为shell设置
主流有三种
bash,(原生)
zsh,(推荐)
fish,(杂技)

Linux常用shell种类
不同的shell具备不同的功能，shell还决定了Linux中默认的shell是/bin/bash，流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。

bash(默认版本)
大多数Linux系统默认使用的shell，bash shell是Bourne shell 的一个免费版本，它是最早的Unix shell,bash还有一个特点，可以通过help命令
来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。

zsh(插件多,推荐使用)
目前Linux里最庞大的一种shell：zsh。它有84个内部命令，使用起来也比较复杂。一般情况下，不会使用
该shell。

fish(杂技感强,不推荐在生产环境中使用)
Fish 是"the friendly interactive shell"的简称，最大特点就是方便易用。很多其他 Shell 需要配置才有的功能，Fish 默认提供，不需要任何配置。
https://www.ruanyifeng.com/blog/2017/05/fish_shell.html


csh
C shell 使用的是“类C”语法，csh是具有C语言风格的一种shell，其内部命令有52个，较为庞大。目前使用的并不多，
已经被/bin/tcsh所取代。

ksh
Korn shell 的语法与Bourne shell相同，同时具备了C shell的易用特点。许多安装脚本都使用ksh,ksh 有42条内部命令，与bash相比有一定的限制性。

tcsh
tcsh是csh的增强版，与C shell完全兼容。

sh
是一个快捷方式，已经被/bin/bash所取代。

nologin
指用户不能登录






linux操作系统：服务器领域之王,是从unix演化过来的,开源社区。
1.linux运维工程师

2.linux嵌入工程师(c++,c语言入土把)
linux内核开源，占有存储空间小。

3.linux开发程序员
一定要问linux版本：
centose 常用主流
redhat 安全开发。
ubuntu(我) 个人主流
kalios 安全渗透。

六个阶段:技术到位，linux吉祥物企鹅
1.文件和用户的curd
2.linux配置文件
3.开发环境搭建(环境变量配置，网络配置，服务配置，解释器or编译器)
4.书写shell脚本
5.能安全设置，防止攻击，保障服务器正常运行，能对系统调优
6.深入理解linux内核，熟练掌握大型网站应用架构组成，并熟悉各个环境的部署和维护方法

基本指令
ctrl + alt + T打开终端

设置共享文件夹1.windows共享 2.ubuntu共享，将文件夹映射到局域网内。

clear清屏

查询系统版本
cat /proc/version
cat /etc/issue

ifconfig 查询ip地址inet addr192.168.184.128
xshell可以用，win10自带openssh,安装即可
xftp上传下载文件, 当然文件小用ssh自带的src也一样

将远程服务器上的文件复制到本机
===================================================================
   1.登录（-p 指定端口）                   
       ssh -p22 omd@192.168.25.137
   1.调试模式（-v端口调试  -C数据压缩 -F比对密钥）                   
       ssh -p 22 -v omd@192.168.25.137 	   
   2.直接执行命令  -->最好全路径                   
       ssh root@192.168.25.137 ls -ltr /backup/data                       
           ==>ssh root@192.168.25.137 /bin/ls -ltr /backup/data               
   3.查看已知主机                    
        cat /root/.ssh/known_hosts
   4.ssh远程执行sudo命令
       ssh -t omd@192.168.25.137 sudo rsync hosts /etc/
 

 
5.scp               
scp 跨机远程拷贝
scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。

scp命令参数

-1 强制scp命令使用协议ssh1
-2 强制scp命令使用协议ssh2
-4 强制scp命令只使用IPv4寻址
-6 强制scp命令只使用IPv6寻址
-B 使用批处理模式（传输过程中不询问传输口令或短语）
-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p 留原文件的修改时间，访问时间和访问权限。
-q 不显示传输进度条。
-r 递归复制整个目录。
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，
-P port 注意是大写的P, port是指定数据传输用到的端口号
-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
scp一般有六种使用方法
本地复制远程文件：（把远程的文件复制到本地）
scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz
远程复制本地文件：（把本地的文件复制到远程主机上）
scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz
本地复制远程目录：（把远程的目录复制到本地）
scp -r root@www.test.com:/val/test/ /val/test/
远程复制本地目录：（把本地的目录复制到远程主机上）
scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipi
pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ piting@192.168.0.172:/media/data/pipi/datasets

本地复制远程文件到指定目录：（把远程的文件复制到本地）
scp root@www.test.com:/val/test/test.tar.gz /val/test/
远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）
scp /val/test.tar.gz root@www.test.com:/val/

 
   6.ssh自带的sftp功能               
             1.Window和Linux的传输工具                   
                  wincp   filezip                   
               sftp  -->基于ssh的安全加密传输                   
               samba   
             2.sftp客户端连接                   
                sftp -oPort=22 root@192.168.25.137                   
                put /etc/hosts /tmp                   
                get /etc/hosts /home/omd   
            3.sftp小结：                   
                1.linux下使用命令： sftp -oPort=22 root@x.x.x.x                   
                2.put加客户端本地路径上传                  
                3.get下载服务器端内容到本地                   
                4.远程连接默认连接用户的家目录
				
ssh  [user@]host [command]

    选项：

    -1：强制使用ssh协议版本1；

    -2：强制使用ssh协议版本2；

    -4：强制使用IPv4地址；

    -6：强制使用IPv6地址；

    -A：开启认证代理连接转发功能；

    -a：关闭认证代理连接转发功能；

    -b：使用本机指定地址作为对应连接的源ip地址；

    -C：请求压缩所有数据；

    -F：指定ssh指令的配置文件；

    -f：后台执行ssh指令；

    -g：允许远程主机连接主机的转发端口；

    -i：指定身份文件；

    -l：指定连接远程服务器登录用户名；

    -N：不执行远程指令；

    -o：指定配置选项；

    -p：指定远程服务器上的端口；

    -q：静默模式；

    -X：开启X11转发功能；

    -x：关闭X11转发功能；

    -y：开启信任X11转发功能。
				
				

==========================================================================================================
    ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：

    所创建的内核文件的大小、

    进程数据块的大小、

    Shell 进程创建文件的大小、

    内存锁住的大小、

    常驻内存集的大小、

    打开文件描述符的数量、

    分配堆栈的最大大小、

    CPU 时间、

    单个用户的最大线程数、

   Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。

永久修改的方法
vi /etc/profile 用户环境配置文件
source /etc/profile 配置生效

临时查看，并修改的方法
ulimit [参数符] [参数值]			
ulimit -n 用户可以打开文件的最大数目
ulimit -H 设置硬资源限制，一旦限制不能增加
ulimit -S 设置软资源，可以增加，不能超过硬资源上限
ulimit -a 显示当前所有limit信息
ulimit -c 最大的core文件大小
ulimit -d 进程最大的数据大小kb
ulimit -f 进程创建文件的最大值kb
ulimit -l 最大加锁内存大小kb
ulimit -m 最大内存大小kb
ulimit -p 管道缓冲区大小kb
ulimit -s 线程栈大小kb
ulimit -t 最大cpu事件s
ulimit -u 用户最大可用进程数
ulimit -v 进程最大可用虚拟内存kb


				
=====================================================================================

history 指令，查看历史指令

解决中文乱码？有的是方法。常用cat，vim编辑可以set encoding=utf-8

调出帮助文档
当我们对某个指令不熟悉时，可以使用help cd指令

系统信息
arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
查询服务器型号：dmidecode -t 1
查询主板信息：dmidecode -t 2
查看CPU型号
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
查看CPU物理个数
cat /proc/cpuinfo |grep "physical id" | sort | uniq | wc -l
查看单个CPU核数
cat /proc/cpuinfo| grep "cpu cores"| uniq
查看CPU逻辑数
cat /proc/cpuinfo| grep "processor"| wc -l
查看内存型号
dmidecode -t 17
查看内存插槽数和当前内存数
dmidecode|grep -P -A5 "Memory Device" |grep Size


hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 
lspci -tv 罗列 PCI 设备 
lsusb -tv 显示 USB 设备 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 - 月日时分年.秒
date -s “年-月-日 11:22:33” 设置系统时间
clock -w 将时间修改保存到 BIOS
cal 日历


关机 (系统的关机、重启以及登出 ) 
shutdown -h now 关闭系统
shutdown -h 1   一分钟后关机
init 0 关闭系统
telinit 0 关闭系统
shutdown -h hours:minutes & 按预定时间关闭系统 
shutdown -c 取消按预定时间关闭系统 
shutdown -r now 重启
reboot 重启
logout 注销
sync   注意细节，记得将内存数据放到磁盘上 
halt 和shutdown一样用法


文件和目录 
cd /home 进入 '/ home' 目录' 
cd .. 返回上一级目录 
cd ../.. 返回上两级目录 
cd 进入个人的主目录 
cd ~user1 进入个人的主目录 
cd - 返回上次所在的目录 
pwd 显示工作绝对路径
ls 查看目录中的文件 
ls -F 查看目录中的文件 
ls -l 显示文件和目录的详细资料 
ls -a 显示隐藏文件 
ls *[0-9]* 显示包含数字的文件名和目录名 
tree 显示文件和目录由根目录开始的树形结构
lstree 显示文件和目录由根目录开始的树形结构
mkdir dir1 创建一个叫做 'dir1' 的目录' 
mkdir dir1 dir2 同时创建两个目录
mkdir -p /tmp/dir1/dir2 创建一个目录树 
rm -f file1 删除一个叫做 'file1' 的文件' 
rmdir dir1 删除一个叫做 'dir1' 的目录' 
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 
rm -rf dir1 dir2 同时删除两个目录及它们的内容 
mv dir1 new_dir 重命名/移动 一个目录 
cp file1 file2 复制一个文件 
cp dir/* . 复制一个目录下的所有文件到当前工作目录 
cp -a /tmp/dir1 . 复制一个目录到当前工作目录 
cp -a dir1 dir2 复制一个目录 
cp -r dir1 dir2 复制一个目录及子目录

ln -s file1 lnk1 创建一个指向文件或目录的软链接,像win的快捷方式
ln file1 lnk1 创建一个指向文件或目录的物理链接，像win的快捷方式

touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)
touch 文件名  创建一个文件名
file file1 outputs the mime type of the file as text 
iconv -l 列出已知的编码 
iconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 
find . -maxdepth 1 -name *.jpg -print -exec convert "{}" -resize 80x60 "thumbs/{}" \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 

文件搜索 find [/查找范围] [-类型] 关键字
find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 'user1' 的文件和目录 
find / -size +20M 找大于20M的文件
find / -size -20M 找小于20M的文件
find / -size 20M  找等于20M的文件
find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 
find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限 
find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 
locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 也要先安装apt-get install mlocate
whereis halt 显示一个二进制文件、源码或man的位置 
which halt 显示一个二进制文件或可执行文件的完整路径 


grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词"Aug" 
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以"Aug"开始的词汇 
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行 
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串"Aug" 
grep -n yes区分大小写
grep -ni yes不区分大小写

管道符“|”       将前命令|传递给后命令执行
root@c553a9743299:/# cat hallo_world | grep yes
yes




挂载一个文件系统 
mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在 
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出 
fuser -km /mnt/hda2 当设备繁忙时强制卸载 
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 
mount /dev/fd0 /mnt/floppy 挂载一个软盘 
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom 
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom 
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom 
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 



磁盘空间 
df -h 显示已经挂载的分区列表，磁盘使用情况
df -lh 类似上一条
df -h filedir 查询文件目录占用
ls -lSr |more 以尺寸大小排列文件和目录 
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间' 
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小
du -h 指定目录体积
du -s 带计量单位
du -a 含文件
du --max-depth=1 子目录深度
du -c 列出明细的同时增加汇总值
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) 
dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 

列出home的目录  筛选普通文件-  用wc计数
ls -l /home | grep "^-" | wc -l 




用户和群组,当用户登录时，会进入自己的home位置（出生地），linux的用户至少要属于一个组
cat /etc/passwd 可以查看所有用户
cat /etc/group   查看组用户
cat /etc/shadow   查看密码
groupadd group_name 创建一个新用户组 
groupdel group_name 删除一个用户组 
groupmod -n new_group_name old_group_name 重命名一个用户组 
useradd -c "docs " -g [group组名] -d /home/user1 -s /bin/bash [user1用户名] 创建一个属于 "admin" 用户组的用户 
useradd user1 创建一个新用户
userdel -r user1 删除一个用户 ( '-r' 删除家目录)
userdel userl	删除一个用户

★
usermod -c "User FTP" -g system新组 -d /ftp/user1 -s /bin/nologin user1用户 修改用户属性 


passwd 修改口令
passwd user1 修改一个用户的口令 (只允许root执行)
chage -E 2005-12-31 user1 设置用户口令的失效期限 
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户 
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组 
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 
使用用户登录要注意，权限问题
sudo- 指令
su-   切换用户切换
logout 远程连接时，可以注销当前用户
id userl 查看用户信息


linux系统指令运行级别，起始系统模式。运行级别配置文件/etc/inittab
0 关机
1 单用户（找回丢失密码）,因为是直接进的root下，所以修改密码很容易。
2 多用户无网络服务
3 多用户有网络服务 命令行模式
4 保留
5 图形界面
6 重启
init [03] 执行切换
如何找回丢失的root密码？
进入到单用户模式，然后修改root密码。因为进入root不需要密码。


文件的权限 - 使用 "+" 设置权限，使用 "-" 用于取消,使用“=”修改权限
也可以直接用权限对应的数字r=4,w=2,x=1
ls -lh 显示权限
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 
chown user1 file1 改变一个文件的所有人属性 
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 
chgrp group1 file1 改变文件的用户群组 
chown user1:group1 file1 改变一个文件的所有人和群组属性 
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 
chmod g-s /home/public 禁用一个目录的 SGID 位 
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 
chmod o-t /home/public 禁用一个目录的 STIKY 位






计划任务:定时调用脚本sheel.sh
crontab [选项]
crontab -e 开启编辑sheel
crontab -l 查看脚本
crontab -r 删除脚本
service crond restart
例子:
# crontab -e 进入调度文件
开始编辑
*/1****ls-l /etc/ > /tmp/to.txt       每隔一分钟将文件信息追加到to.txt
*/1****      /tmp/to.sh              每个一分钟执行一下to.sh
保存关闭
第一个"*" 一小时当中的第几分钟 0-59
第二个"*" 一天当中的第几小时   0-23
第三个"*" 一个月当中的第几天   1-31
第四个"*"  一年当中的第几个月  1-12
第五个"*"  一周当中的星期几    0-7
"," 任意时间
"*" 表示不连续时间
"-" 表示连续时间
"*/n" 代表间隔多久执行一次




文件的概念:
1.所有者
2.所在组
3.其他组
4.改变用户所在组
ls -ahl 查看文件所有者，默认创建文件者为文件所有者
chown user1 file   改变文件所有者

文件的特殊属性 - 使用 "+" 设置权限，使用 "-" 用于取消 
chattr +a file1 只允许以追加方式读写文件 
chattr +c file1 允许这个文件能被内核自动压缩/解压 
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 
chattr +s file1 允许一个文件被安全地删除 
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 
lsattr 显示特殊的属性 

参考文献https://blog.51cto.com/u_15669429/5351558
root@777120daaede:/# ls -l
total 72
drwxr-xr-x   2 root root 4096 Dec 20  2021 bin
drwxr-xr-x   2 root root 4096 Oct  3  2021 boot
drwxr-xr-x   5 root root  360 Mar 19 00:09 dev
drwxr-xr-x   2 root root 4096 Dec 21  2021 docker-entrypoint-initdb.d
lrwxrwxrwx   1 root root   34 Dec 21  2021 entrypoint.sh -> usr/local/bin/docker-entrypoint.sh
drwxr-xr-x   1 root root 4096 Feb 14 02:13 etc
drwxr-xr-x   2 root root 4096 Oct  3  2021 home
drwxr-xr-x   1 root root 4096 Dec 21  2021 lib
drwxr-xr-x   2 root root 4096 Dec 20  2021 lib64
drwxr-xr-x   2 root root 4096 Dec 20  2021 media
drwxr-xr-x   2 root root 4096 Dec 20  2021 mnt
drwxr-xr-x   2 root root 4096 Dec 20  2021 opt
dr-xr-xr-x 316 root root    0 Mar 19 00:09 proc
drwx------   1 root root 4096 Dec 21  2021 root
drwxr-xr-x   1 root root 4096 Dec 21  2021 run
drwxr-xr-x   2 root root 4096 Dec 20  2021 sbin
drwxr-xr-x   2 root root 4096 Dec 20  2021 srv
dr-xr-xr-x  11 root root    0 Mar 19 00:09 sys
drwxrwxrwt   1 root root 4096 Mar 19 00:09 tmp
drwxr-xr-x   1 root root 4096 Dec 20  2021 usr
drwxr-xr-x   1 root root 4096 Dec 20  2021 var
|---1-----|-2-|-3-|--4--|--5--|-6--------|-7-|
第一组：
字符1
-普通文件
d目录      
l软连接    r--文件所在用户组权限
c字符设备  r--文件其他组用户权限
b块文件硬盘

字符2-4
当前用户下 rwx读 写 执行(进入)

字符5-7
当前用户的群组 rwx读 写 执行(进入)

字符8-0
其他群组的权限 rwx读 写 执行(进入)

第二组：
count文件数量

第三组：
文件所有者

第四组：
文件所有者的群组

第五组
文件大小 bytes 字节 等价于 B 

第六组
最后修改日期

第七组
文件名







打包和压缩文件 
bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 
bzip2 file1 压缩一个叫做 'file1' 的文件 
gunzip file1.gz 解压一个叫做 'file1.gz'的文件 
gzip file1 压缩一个叫做 'file1'的文件 源文件则消失
gzip -9 file1 最大程度压缩 
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' 
rar x file1.rar 解压rar包 
unrar x file1.rar 解压rar包
tar -cvf archive.tar file1 创建一个非压缩的 tarball 
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 
tar -tf archive.tar 显示一个包中的内容 
tar -xvf archive.tar 释放一个包 
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 
tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 
tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 
zip file1.zip file1 创建一个zip格式的压缩包 
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 
unzip file1.zip 解压一个zip格式压缩包
-------------------------------------------------------------------------------------------------------

./configure # 生成 Makefile 脚本
make # 构建软件
make install # 使用 Makefile 安装软件


整个过程分为三步：

配置
configure 脚本负责在你使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。

Unix 程序一般是用 C 语言写的，所以我们通常需要一个 C 编译器去构建它们。在这个例子中 configure 要做的就是确保系统中有 C 编译器，并确定它的名字和路径。

2. 构建

当 configure 配置完毕后，可以使用 make 命令执行构建。这个过程会执行在 Makefile 文件中定义的一系列任务将软件源代码编译成可执行文件。

你下载的源码包一般没有一个最终的 Makefile 文件，一般是一个模版文件 Makefile.in 文件，然后 configure 根据系统的参数生成一个定制化的 Makefile 文件。

3. 安装

现在软件已经被构建好并且可以执行，接下来要做的就是将可执行文件复制到最终的路径。make install 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。

这通常意味着，可执行文件被复制到某个 PATH 包含的路径，程序的调用文档被复制到某个 MANPATH 包含的路径，还有程序依赖的文件也会被存放在合适的路径。

因为安装这一步也是被定义在 Makefile 中，所以程序安装的路径可以通过 configure 命令的参数指定，或者 configure 通过系统参数决定。

如果要将可执行文件安装在系统路径，执行这步需要赋予相应的权限，一般是通过 sudo。

这些脚本是怎么产生的

安装过程简单说就是 configure 脚本根据系统信息将 Makefile.in 模版文件转换为 Makefile文件，但是 configure 和 Makefile.in 文件是怎么产生的呢？

如果你曾经试着打开 configure 或者 Makefile.in 文件，你会发现超长而且复杂的 shell 脚本语言。有时候这些脚本代码比它们要安装的程序源代码还要长。

如果想手动创建一个这样的 configure 脚本文件是非常可怕的，好消息是这些脚本是通过代码生成的。

通过这种方式构建的软件通常是通过一个叫做 autotools 的工具集打包的。这个工具集包含 autoconf 、automake 等工具，所有的这些工具使得维护软件生命周期变得很容易。最终用户不需要了解这些工具，但却可以让软件在不同的 Unix 系统上的安装步骤变得简单。

Hello world

我们以一个 Hello world 的简单 C 程序为例，来看看如何使用 autotools 打包。

下面是程序源码，源代码文件命名：main.c

#include <stdio.h>

int main(int argc, char* argv[]) {
    println("Hello world\n");
    return 0;
}
创建 configure 脚本

我们不直接写 configure 脚本文件，而是通过创建一个描述文件 configure.ac 来描述 configure 需要做的事情。configure.ac 使用 m4sh 写，m4sh 是 m4 宏命令和 shell 脚本的组合。

第一个用到的宏命令是 AC_INIT，这个命令会初始化 autoconf 并配置一些关于软件的基本信息。下面这行代码表示，软件名是 helloworld，版本是 0.1，维护作者是 george@thoughtbot.com：

AC_INIT([helloworld], [0.1], [george@thoughtbot.com])
因为这个项目需要用到 automake，所以我们要用下面这个命令来初始化它：

AM_INIT_AUTOMAKE
接下来，我们需要告诉 autoconf configure 脚本需要的依赖。在这个例子中，configure 需要的只是 C 编译器，我们可以用下面这个宏命令来设置：

AC_PROG_CC
如果我们需要别的依赖，可以使用别的 m4 宏命令来设置；例如 AC_PATH_PROG 表示在 PATH 上搜索一个特定的程序。

此时我们已经列出了所有的依赖，我们可以使用它们。前面有提到， configure 脚本会根据系统的信息和 Makefile.in 文件生成 Makefile 文件。

下面这个宏命令 AC_CONFIG_FILES 表示让 autoconf 配置 configure 脚本找到 Makefile.in 文件，并将文件内的占位符用对应的值替换，例如将 @PACKAGE_VERSION@ 替换成 0.1，然后将结果写在 Makefile 文件中。

AC_CONFIG_FILES([Makefile])
最后，当我们把所有配置信息都告诉 autoconf 后，可以使用 AC_OUTPUT 命令去输出脚本：

AC_OUTPUT
下面这段代码是 configure.ac 中的所有代码，相比 4737 行的 configure 脚本文件，这些代码好懂多了

AC_INIT([helloworld], [0.1], [george@thoughtbot.com])
AM_INIT_AUTOMAKE
AC_PROG_CC
AC_CONFIG_FILES([Makefile])
AC_OUTPUT
还差一点我们就可以发布软件了，configure 脚本需要一个 Makefile.in 文件，将系统相关信息填充进去后，生成最终的 Makefile 文件。

创建 Makefile 文件

查看 Makefile.in 脚本发现它的代码又长又复杂，手写不太可能。不过可以先写一个 Makefile.am 脚本，然后通过 automake 工具生成 Makefile.in 脚本。Makefile.am 脚本相比 Makefile.in 简单一些，接下来看看如何去写。

首先需要告诉 automake 项目的结构，因为这里的例子不是标准的 GNU 项目的结构，所以结构声明为 foreign：

AUTOMAKE_OPTIONS = foreign
接下来告诉 automake 需要 Makefile 构建的软件名字：

bin_PROGRAMS = helloworld
上面这行代码其实包含了很多信息，这多亏了 automake 的命名规则。

PROGRAMS 称为「primary 主要」字段，它告诉了 automakehelloworld 文件的属性。例如这里的 PROGRAMS 表示这个文件需要编译，而属性是 SCRIPTS 或 DATA 的文件则不需要编译。

这里的 bin 前缀则是在告诉 automake 后面的文件需要安装在 bindir 变量所指示的路径下。类似 bindir 这样变量还有 libdir 和 pkglibdir，这些都是 autotools 定义的变量，也可以创建自定义的变量。

如果项目中包含 Ruby 脚本，可以定义 rubydir 变量，用来记录安装 Ruby 脚本的地方：

rubydir = ${datadir}/ruby
ruby_DATA = my_script.rb my_other_script.rb
安装路径前可以再一些前缀来让 automake 做一些别的操作。

因为定义了 「PROGRAMS 程序」，所以需要告诉 automake 它的源文件。下面这行代码里，前缀 helloworld 表示编译的软件名字，而不是要安装的的路径。

helloworld_SOURCES = main.c
下面这段是 Makefile.am 脚本的完整代码，和 configure.ac 一起编译 helloworld 软件。相比它生成的 Makefile.in 脚本代码少了很多：

AUTOMAKE_OPTIONS = foreign
bin_PROGRAMS = helloworld
helloworld_SOURCES = main.c
生成文件

现在已经写好了所有需要的脚本，使用 autotools 就可以生成 configure 和 Makefile.in 脚本。

首先需要为 autotools 准备 m4 脚本环境：

aclocal
接下来使用 autoconf 将 configure.ac 生成 configure 脚本，用 automake 将 Makefile.am 生成为 Makefile.in 脚本：

autoconf
automake --add-missing
发布软件

最终使用软件的用户不需要关心使用 autotools 的部分，所以我们只需要把 configure 和 Makefile.in 脚本发布出去就可以了，不需要前面写的脚本。

autotools 也可以帮我们发布软件。Makefile 里有各种各样的命令，包括构建一个可以发布的软件包：

./configure
make dist
还可以测试软件包能否在各种版本系统上安装：

make distcheck
总结

现在终于知道这段安装命令的来历和工作原理了！

下面分别展示下软件发布和安装的命令：

发布：

aclocal # 设置m4 环境
autoconf # 生成 configure 脚本
automake --add-missing # 生成 Makefile.in 脚本
./configure # 生成 Makefile 脚本
make distcheck # 使用 Makefile 构建一个发布软件并测试




make命令 是GNU的工程化编译工具，用于编译众多相互关联的源代码问价，以实现工程化的管理，提高开发效率。
语法
make(选项)(参数)
选项
-f：指定“makefile”文件；
-i：忽略命令执行返回的出错信息；
-s：沉默模式，在执行之前不输出相应的命令行信息；
-r：禁止使用build-in规则；
-n：非执行模式，输出所有执行命令，但并不执行；
-t：更新目标文件；
-q：make操作将根据目标文件是否已经更新返回"0"或非"0"的状态信息；
-p：输出所有宏定义和目标文件描述；
-d：Debug模式，输出有关文件和检测时间的详细信息。
Linux下常用选项与Unix系统中稍有不同，下面是不同的部分：

-c dir：在读取 makefile 之前改变到指定的目录dir；
-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；
-h：help文挡，显示所有的make选项；
-w：在处理 makefile 之前和之后，都显示工作目录。

./shell.sh 启动shell文件



__________________________________________________________________________________
RPM 包 - （Fedora, Redhat及类似系统）
redhat比较喜欢centos，ubuntu我喜欢
红帽包软件包管理工具，类似windows setup
rpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包
rpm -ivh package.rpm 安装一个rpm包 
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 
rpm -U package.rpm 更新一个rpm包但不改变其配置文件 
rpm -F package.rpm 更新一个确定已经安装的rpm包 
rpm -e package_name.rpm 删除一个rpm包 
rpm -qa 显示系统中所有已经安装的rpm包
rpm -qi package_name 获取一个已安装包的特殊信息 
rpm -qg "System Environment/Daemons" 显示一个组件的rpm包 
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 
rpm -q package_name --whatprovides 显示一个rpm包所占的体积 
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l 
rpm -q package_name --changelog 显示一个rpm包的修改历史 
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 
rpm --checksig package.rpm 确认一个rpm包的完整性 
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 
rpm -Va 检查系统中所有已安装的rpm包- 小心使用 
rpm -Vp package.rpm 确认一个rpm包还未安装 
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 

YUM 软件包升级器 - （Fedora, RedHat及类似系统） 
yum install package_name 下载并安装一个rpm包 
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 
yum update package_name.rpm 更新当前系统中所有安装的rpm包 
yum update package_name 更新一个rpm包 
yum remove package_name 删除一个rpm包 
yum list 列出当前系统中安装的所有包 
yum search package_name 在rpm仓库中搜寻软件包 
yum clean packages 清理rpm缓存删除下载的包 
yum clean headers 删除所有头文件 
yum clean all 删除所有缓存的包和头文件 
------------------------------------------------------------------------------------------


DEB 包 (Debian, Ubuntu 以及类似系统) 
dpkg -i package.deb 安装/更新一个 deb 包 
dpkg -r package_name 从系统删除一个 deb 包 
dpkg -l 显示系统中所有已经安装的 deb 包 
dpkg -l | grep httpd 显示所有名称中包含 "httpd" 字样的deb包 
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 


apt和apt-get其中apt的包管理工具更值得推荐！！！

APT 软件工具 (Debian, Ubuntu 以及类似系统) 
apt-get install package_name 安装/更新一个 deb 包 
apt-cdrom install package_name 从光盘安装/更新一个 deb 包 
apt-get update 升级列表中的软件包 
apt-get upgrade 升级所有已安装的软件 
apt-get remove package_name 从系统删除一个deb包 
apt-get check 确认依赖的软件仓库正确 
apt-get clean 从下载的软件包中清理缓存 
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 

----------------------------------------------------------------------------------------------

查看文件内容 
cat file1 从第一个字节开始正向查看文件的内容 
tac file1 从最后一行开始反向查看一个文件的内容 
more file1 查看一个长文件的内容 
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 
head -2 file1 查看一个文件的前两行 
tail -2 file1 查看一个文件的最后两行 
tail -f /var/log/messages 实时查看被添加到一个文件中的内容 
echo 输出环境变量，输出内容

文本处理 
cat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT 
cat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中
cat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中
ls-l > 文件 将列表内容写入覆盖写入文件中
ls-al >> 文件 将列表内容追加写入文件中
cat 文件1>文件2   将文件1覆盖到文件2中
echo "内容">>文件  将内容追加文件中


sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 "string1" 替换成 "string2" 
sed '/^$/d' example.txt 从example.txt文件中删除所有空白行 
sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行 
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容 
sed -e '1d' result.txt 从文件example.txt 中排除第一行 
sed -n '/stringa1/p' 查看只包含词汇 "string1"的行 
sed -e 's/ *$//' example.txt 删除每一行最后的空白字符 
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 "string1" 并保留剩余全部 
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容 
sed -n '5p;5q' example.txt 查看第5行 
sed -e 's/00*/0/g' example.txt 用单个零替换多个零 
cat -n file1 标示文件的行数 
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行 
echo a b c | awk '{print $1}' 查看一行第一栏 
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏 
paste file1 file2 合并两个文件或两栏的内容 
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用"+"区分 
sort file1 file2 排序两个文件的内容 
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) 
sort file1 file2 | uniq -u 删除交集，留下其他的行 
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) 
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 




字符设置和文件格式转换 
dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX 
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS 
recode ..HTML < page.txt > page.html 将一个文本文件转换成html 
recode -l | more 显示所有允许的转换格式 



文件系统分析 
badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 

linux分区，只有一个根目录。
mount挂载，所有分区都是对应的文件夹
umount卸载
硬盘的各个分区标识
# lsblk -f查看系统分区
IDE硬盘 驱动器标识符 hdx~      ~表示1234是主分区，其他数字逻辑分区
SCSI硬盘 sdx~                  x表示挂载硬盘符abcdefg

给linux挂载一块硬盘sdb1，挂载到/home/newdisk
# 重启linux系统，才能看到挂载的新盘符
# fdisk /dev/sdb 分区操作进入数据帮助 输入 m n p w
# 进行格式化    mkfs -t ext4 /dev/sdb1 创建ext4文件系统
将硬盘挂载某个目录
创建新目录mkdir /home/newdisk
临时挂载mount /dev/sdb1 /home/newdisk
永久挂载
vim /etc/fstab 记录了文件分区和挂载点修改这里的UUID即可。
修改完毕输入 mount -a 即可自动挂载
umount /dev/sdb1 即可卸载


xfs文件系统，高性能文件系统
EFI UEFI启动分区


初始化一个文件系统 
mkfs /dev/hda1 在hda1分区创建一个文件系统 
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 
fdformat -n /dev/fd0 格式化一个软盘 
mkswap /dev/hda3 创建一个swap文件系统 



SWAP文件系统虚拟内存
mkswap /dev/hda3 创建一个swap文件系统 
swapon /dev/hda3 启用一个新的swap文件系统 
swapon /dev/hda2 /dev/hdb3 启用两个swap分区 



备份 
dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份 
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份 
restore -if /tmp/home0.bak 还原一个交互式备份 
rsync -rogpav --delete /home /tmp 同步两边的目录 
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync 
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作 
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作 
( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p' 通过ssh在远程目录中复制一个目录内容 
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' 通过ssh在远程目录中复制一个本地目录 
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录 
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包 
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 



光盘 
cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 
mkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件 
mkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 
mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 
cd-paranoia -- "-3" 从一个CD光盘转录音轨到 wav 文件中（参数-3） 
cdrecord --scanbus 扫描总线以识别scsi通道 
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 



网络 - （以太网和WIFI无线）
NAT模式

doker linux是通过虚拟网关连接
以太网适配器 vEthernet (WSL):
   连接特定的 DNS 后缀 . . . . . . . :
   本地链接 IPv6 地址. . . . . . . . : fe80::b83f:200f:5d17:6d42%45
   IPv4 地址 . . . . . . . . . . . . : 172.18.0.1
   子网掩码  . . . . . . . . . . . . : 255.255.240.0
   默认网关. . . . . . . . . . . . . : 

服务器必须，配置静态ip地址
ifconfig eth0 显示一个以太网卡的配置
ifup eth0 启用一个 'eth0' 网络设备 
ifdown eth0 禁用一个 'eth0' 网络设备 
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing) 
dhclient eth0 以dhcp模式启用 'eth0' 
配置网卡地址
/etc/sysconfig/network-scripts/ifcfg-eth0       eth0这个网卡的配置文件
# vi /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0     #网卡设备名称
ONBOOT=yes      #启动时是否激活 yes | no
BOOTPROTO=static        #协议类型
IPADDR=192.168.1.90     #网络IP地址
NETMASK=255.255.255.0       #网络子网地址
GATEWAY=192.168.1.1     #网关地址
BROADCAST=192.168.1.255     #广播地址
HWADDR=00:0C:29:FE:1A:09        #网卡MAC地址
TYPE=Ethernet       #网卡类型为以太网

service network restart 重启网卡

netstat -anp 查看网络状态

route -n show routing table 
route add -net 0/0 gw IP_Gateway configura default gateway 
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16' 
route del 0/0 gw IP_gateway remove static route 
echo "1" > /proc/sys/net/ipv4/ip_forward activate ip routing 
hostname show hostname of system 
host www.example.com lookup hostname to resolve name to ip address and viceversa
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa
ip link show show link status of all interfaces 
mii-tool eth0 show link status of 'eth0' 
ethtool eth0 show statistics of network card 'eth0' 
netstat -tup show all active network connections and their PID 
netstat -tupl show all network services listening on the system and their PID 
tcpdump tcp port 80 show all HTTP traffic 
iwlist scan show wireless networks 
iwconfig eth1 show configuration of a wireless network card 
hostname show hostname 
host www.example.com lookup hostname to resolve name to ip address and viceversa 
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa 
whois www.example.com lookup on Whois database 

----------------------------------------------------------------------------------
javaEE环境配置
安装jdk
jdk1.7.gz
yum -y java:latest
1.配置文件
vim /etc/profile
JAVA_HOME = /opt/jdk1.7.0_79
PATH = /opt/jdk1.7.0_79/bin:$PATH
export JAVA_HOME PATH
2.注销用户
logout
3.测试安装成功
javac 编译
java  运行
java脚本叫.class

安装web服务器
tomcat.gz
yum -y tomcat
进入tomcat/bin的目录
./startup.sh 启动服务端
localhost:8080可以看到tomcat的主页
设置防火墙 开放端口
vim /etc/sysconfig/iptables
放行8080
service iptables restart重启墙
容器外可以访问

安装IDE-Linux
eclipse.gz
yum -y eclipse
启动./eclipse 配置ire and service

安装
mysql.gz
apt-get mysql-server
配置工具





JPS工具查询管理java程序

jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。

    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。

     使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。

jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.

$> jps
23991 Jps
23789 BossMain
23651 Resin


-----------------------------------------------------
1.查看防火墙当前状态ubuntu
sudo ufw status
2.开启防火墙
sudo ufw enable
3.关闭防火墙
sudo ufw disable
4.查看防火墙版本
sudo ufw version
5.默认允许外部访问本机
sudo ufw default allow
6.默认拒绝外部访问主机
sudo ufw default deny
7.允许外部访问53端口
sudo ufw allow 53
8.拒绝外部访问53端口
sudo ufw deny 53
9.允许某个IP地址访问本机所有端口
sudo ufw allow from 192.168.0.1

centos命令
网络服务常用命令
systemctl status network.service         #查看网络服务状态
systemctl start network.service          #启动网络服务
systemctl stop network.service           #停止网络服务
systemctl restart network.service        #重启网络服务
systemctl enable NetworkManager	          #设置开机自启

防火墙常用命令
firewall-cmd --state 查看防火墙当前状态
systemctl stop firewalld.service         #关闭防火墙
systemctl disable firewalld.service      #关闭开机自启
systemctl enable firewalld.service       #设置开机自启

系统ntp服务
systemctl status ntpd              #检查ntp服务状态
systemctl enable ntpd              #设置ntp服务为开机自启
systemctl start ntpd               #开启ntp服务

系统定时任务
systemctl restart crond.service     （重启定时任务）
systemctl status crond.service     （查看定时任务状态）





老版本service服务linux后台主服务,很多软件依赖
新服务systemctl
systemctl iptables static 防火墙状态
systemctl iptables start 启动
systemctl iptables stop 停止
ls -l /etc/init.d/ 查看服务
setup        查看服务

iptables


chkconfig --list|grep xxx 查看服务
chkconfig 服务名 --list
chkconfig --level 5 服务名 on/off防火墙动作
-------------------------------------------------------------------------------
进程管理
linux每执行一个程序，都会有一个id
ps 查看系统进程
ps -a 查看所有进程
ps -u 以用户方式显示进程
ps -x 后台运行参数
ps -ef 显示
root@c553a9743299:/# ps -aux | more
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT状态 START   TIME COMMAND启动文件
root         1  0.0  0.0   4240  3476 pts/0    Ss+      09:43   0:00 /bin/bash
root        10  0.0  0.0   4240  3716 pts/1    Ss       09:43   0:00 /bin/bash
root        32  0.0  0.0  25656  2992 ?        Ss       09:44   0:00 /usr/sbin/sshd
root        91  0.0  0.0   5896  2932 pts/1    R+       11:08   0:00 ps -aux
root        92  0.0  0.0    180     4 pts/1    D+       11:08   0:00 [more]
root@c553a9743299:/#

杀死进程
kill pid
通过进程的名称来批量终止进程   
killall user  杀死名字相同的进程
kill -9 pid 强制结束
pstree -p 树状显示pid
pstree -u
======================================================================
后台开启python脚本.
&：将当前命令以后台的形式运行；
ctrl+z：将前台任务转后台并冻结；
bg：将后台冻结的任务再次运行起来；
fg：将后台任务重新转前台执行；
disown：隔离终端挂断信号，事后使用；
(cmd)：创建一个独立shell来执行命令；
jobs：查看在后台运行的任务列表；

方法一
nohup python3 -u app.py > test.out 2>&1 &
tail -f /var/log/messages 实时查看被添加到一个文件中的内容

test.out 就被放在当前目录下
nohup+最后面的& 是让命令在后台执行
>out.log 是将信息输出到out.log日志中
2>&1 是将标准错误信息转变成标准输出，这样就可以将错误信息输出到out.log 日志里面来。

方法二
setsid python3 -u app.py > test.out 2>&1 &

方法三
(python3 -u app.py > test.out 2>&1 &)
当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上& 实现后台运行.

===============================================================================

windows下开启telnet功能
dos中输入telnet ip + 端口

监控进程服务
top -d -i 实时刷新进程state 状态
开启监控后
k 开始杀死进程
u 筛选user
P cpu
M 内存
N PID排序
q 退出


比较常用的参数：

-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
$>  jps -q
28680
23789
23651

-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null

$> jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log

-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名

$> jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin

-v 输出传递给JVM的参数

$> jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl

sudo jps看到的进程数量最全

jps 192.168.0.77

列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099

（前提是远程服务器提供jstatd服务）

注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。
——————————————————————————————————————————————————————————————————————————————————————————
shell篇
shell是一个命令解释器，为用户服务器集群管理需要编写shell
等号不能有空格

入门：
.sh文件中内容
头文件#!/bin/bash
echo "hallo world!"

记得给.sh文件权限x
chmod 744 file.sh

相对路径执行 ./file.sh
绝对路径执行 /shell/file.sh
命令执行     sh file.sh

shell的变量：
系统变量（全局变量）
echo "PATH=$PATH"
echo "user=$USER"

用户变量（局部变量）
A=100
echo "A=$A"
unset A 注销A
echo "A=$A"


readonly A=99 定义静态变量
echo "A=$A"
unset A   静态变量不能unset
echo "A=$A"

将命令的结果返回给变量
RESULT=`ls -l /home` 反引号将linux命令反馈
echo $RESULT
echo ""
MY_DATE=$(date)  括命令将linux命令反馈
echo "date=$MY_DATE"

设置环境变量
export 变量=变量值
source 配置文件 
echo $变量名
为了让/etc/profile的环境生效，需要使用source /etc/profile
vim /etc/profile
#定义一个自己的环境变量
TOMCAT_HOME=/opt/tomcat
export TOMCAT_HOME
#使用我们自定的环境变量
vim /shell/hallo_world.sh
echo "tomcathome=$TOMCAT_HOME"

位置参数变量
$n 0-9位置
$* 合并
$@ 合并
$# 计数

positionPara.sh文件内
#!/bin/bash
#获取到各个参数
echo "$0 $1 $2"
echo "$*"
echo "$@"
echo "参数个数=$#"

# sh positionPara.sh 30 60


预定义变量
$$ 当前进程号
$! 后台最后一个进程号
$? 返回最后一次执行命令的状态  0则正确，其他则不正确
root@c553a9743299:/shell# cat preVar.sh
#!/bin/bash
echo "当前进程号=$$"
#后台方式运行hallo_world.sh
./hallo_world.sh &
echo "最后的进程号=$!"
echo "执行的效果=$?"

运算符
"$((运算式))" 或者 "$[运算式]"
expr m + n
注意要有空格
expr m - n
expr /除 %取余 \*乘法

root@c553a9743299:/shell# vim demo.sh
root@c553a9743299:/shell# sh demo.sh
number=3
root@c553a9743299:/shell# cat demo.sh
#!/bin/bash
number=$((1+2))
echo "number=$number"
root@c553a9743299:/shell#

条件判断,非空即真
if  [atgulgu]              
then 
      echo "equal"         满足则返回

fi
[condition]&&echo OK || echo notok            条件满足，执行后面语句
整数比较
-lt 小于
-le 小于等于
-eq 等于
-gt 大于
-ge 大于等于
-ne 不等于
按照文件权限进行判断
-r 可读
-w 可写
-x 可执行
按照文件类型进行判断
-f 文件存在
-e 文件存在
-d 目录存在

# vim demo.sh
if [23 -gt 22]
then
	echo "大于"
fi

# vim demo.sh
if [-e /etc/world.txt]
then
	echo "大于"
fi

★流程控制
if判断
if [];then
  code
fi


if [3 -dt 4]
then
    echo "对吗"
elif [4 -dt 33]
then
	echo "错吗"
fi


case判断
root@c553a9743299:/shell# vim textcase.sh
root@c553a9743299:/shell# sh textcase.sh
other
root@c553a9743299:/shell# sh textcase.sh 1
周一

case $变量名 in
"1")
echo "周一"
;;
"2")
echo "周二"
;;
*)
echo "结束"
;;
esac


for循环
for 变量 in 值1，2，3
do
	echo "yes"
done

for((初始值；循环控制条件，增量))         c语言?
do
	echo "乱来"
done

#!/bin/bash
sum=0
for((i=1;i<=100;i++))         c语言?
do
	sum=$[$sum+$i]
done
echo "sum=$sum"


#!/bin/bash
for i in "$*"     # $*是合并输入
do
	echo "the num is $i"
done


#!/bin/bash
for i in "$@"    # $@是离散输入
do
	echo "the num is $i"
done


while循环
#!/bin/bash
i=0
while [$i -le 100]
do	
	i=$[$i+1]
	echo "啊啊啊啊"
done

read读取控制台输入
-p 指定读取值时的提示符
-t 指定读取值时等待的时间，如果没有在指定时间内输入，就不等待了
#!/bin/bash
read -p "请输入一个数:" NUM1
echo "你输入的值是:$NUM1"

#!/bin/bash
read -p -t 10 "请输入一个数:" NUM2
echo "你输入的值是:$NUM2"

函数介绍
basename基本语法，返回完整路径最后/的部分，常用于获取文件名
basename file_path       带后缀
basename file_path .txt  不带后缀

dirname 返回文件路径
dirname /home/aaa/text.txt      不带文件名

自定义函数
function funname(){
	echo "世界"
}
调用直接
# funname 实参


案列
#!/bin/bash

#完成数据库的定时备份。
#备份的路径
BACKUP=/data/backup/db
#当前的时间作为文件名
DATETIME=$(date +%Y_%m_%d_%H%M%S)
#可以输出变量调试
#echo ${DATETIME}

echo "=======开始备份========"
echo "=======备份的路径是 $BACKUP/$DATETIME.tar.gz"

#主机
HOST=localhost
#用户名
DB_USER=root
#密码
DB_PWD=root
#备份数据库名
DATABASE=atguiguDB
#创建备份的路径
#如果备份的路径文件夹存在，就使用，否则就创建
[ ! -d "$BACKUP/$DATETIME" ] && mkdir -p "$BACKUP/$DATETIME"
#执行mysql的备份数据库的指令
mysqldump -u${DB_USER} -p${DB_PWD} --host=$HOST  $DATABASE | gzip > $BACKUP/$DATETIME/$DATETIME.sql.gz
#打包备份文件
cd $BACKUP
tar -zcvf $DATETIME.tar.gz $DATETIME
#删除临时目录
rm -rf $BACKUP/$DATETIME

#删除10天前的备份文件
find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "=====备份文件成功==========="



