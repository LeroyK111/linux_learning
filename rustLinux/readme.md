# rust进入linux

## 首次引入
自 Linux 6.1 将最初的 Rust 基础架构添加到 Linux 内核以来，已经合并了许多其他设施和内部修改，以便能够用 Rust 编程语言编写内核驱动程序。

## 重写驱动
在即将到来的 Linux 6.8 内核中，第一个 Rust 网络驱动程序将被引入。这个用 Rust 重写的 ASIX PHY 驱动程序约有 135 行 Rust 代码，该驱动已有 C 语言驱动。PHY 驱动程序是指网卡收发器的物理层驱动。


## 多核实时操作系统的确定性调度设计

多核处理器在提升装备处理性能的同时也带来了一系列不确定性问题，并直接影响装备的实时性、可靠性，相比单核系统，多核并行系统在总线、内存等诸多核间资源同步、任务在不同核上高度并发，使得多核并行系统在确定性保障技术上有着更高的挑战[1]。当前通过认证的具有高可信度、高安全的实时系统中，系统软件设计仍然停留在单核系统上，例如在航空操作系统中，为了保证关键任务调度时的安全，设计者在多核心中只保留一个处理器运行安全关键的任务，其他处理器核心将被关闭[2]。为此，非常有必要在多核实时操作系统上设计一种确定性的调度方法以保证操作系统的安全性和实时性。

### **分区调度**

在符合ARINC653标准的分区操作系统中，分区有两层概念，一层是空间分区，另一层是时间分区。

空间分区可以将内存划分为互不重叠的内存区域，使得每个分区都有自己独有的存储空间，程序在分区中运行时可以将虚拟地址映射到独有存储空间的物理地址，从而减少不同分区内程序之间的相互干扰。

时间分区是指系统时间被分为多个时间窗口，每个分区占用至少一个时间窗口。通过时间分区的方法使得不同分区运行时间可预测，提高分区内程序运行的实时性、准确性、可预测性。

在符合ARINC653标准的系统中任务调度使用两层调度的方法，上层调度为分区间调度，下层调度为分区内调度。

分区间调度的基本单位是分区，通过分区参数设计[3]、时间片算法的改进等对调度算法进行改进和提高。

分区内调度类似于单核实时操作系统中使用的调度算法，如最早截止时间优先算法、先来先服务算法、最低松度优先算法等[4]。

### **多核架构调度**
目前操作系统有三种多核架构处理方式，每种架构调度有不同的要求和方法。

①对称多处理（Symmetric MultiProcessing,SMP）架构：一个操作系统实例同时管理多个处理器核，应用任务可以在不同处理器之间进行迁移。SMP结构的操作系统最大的特点就是资源共享，每个任务都可以被任意一个CPU执行，任务之间可以通过共享内存进行高效通信。

②非对称多处理（Asymmetric MultiProcessing,AMP)架构：每个处理器核上运行独立操作系统实例，各个操作系统都有自己独占的资源，其他资源由其他系统专享或者分配给各个系统专用，每个处理器核上运行的程序与在一个单独操作系统上运行类似。

③绑定多处理（BoundMultiProcessing,BMP）架构：一个操作系统实例同时管理多个处理器核，但是每个应用任务被绑定在特定的处理器核上，无法在不同的处理器核上进行迁移。



### **确定性调度影响因素及解决办法**

根据适航认证标准DO-297的描述，多核确定性是指多核并行系统对给定输入的响应必须是可预测的，响应的结果在规定的时间段内产生，并具有一定程度的可重复性。因此，通常说多核并行系统是确定的，仅当系统满足以下条件：

①行为完整性：指在正常条件下系统能够正确执行，并且在系统发生内部异常时，行为也是可预测的；

②WCET分析：任务的最坏情况执行时间是可预测的；

③资源需求：软件对其运行环境所使用的资源有明确的界限；

④健壮性分区：使用分区架构时，必须保证每个分区的行为和性能不被其他分区影响。

多处理器技术是一个复杂的系统性架构，同时运行在不同处理器核心上的并行任务对共享资源无序抢占带来了任务执行的不确定性问题[5]。多核共享存储模型带来了多核存储访问的不确定性问题，当各个处理器核心对同一块内存并行访问时，各个处理器核心的内存访问顺序是不可预测的，这会导致程序读取或者写入的数据不是程序设计时预想的流程，会产生未知的程序运行行为，破坏系统的安全运行[6]。

对上述存在的问题，在多核实时分区操作系统中利用分区机制进行时空隔离可以对Cache、内存、I/O等硬件及虚拟地址、互斥锁、线程等软件资源进行有效划分。在编译生成操作系统前，采用静态配置时间调度表的方式解决调度不确定性问题及静态配置任务执行所需资源，减少任务并行运行中因共享资源而相互干扰。通过分区与一个或者多个核进行绑定，缓解任务竞争处理器的不确定性问题。通过为分区分配时间窗口和进行分区的时间同步，提高任务调度时间上的准确性、实时性和执行效率。

### **多核实时调度确定性设计**


常见的多核CPU处理器一般提供硬件机制保证每个处理器核上的Cache一致性，不同核之间数据共享的效率较高，因此运行于多核CPU上的操作系统多采用SMP或BMP架构。而在多核DSP处理器上一般硬件不提供不同处理器核之间的Cache一致性保障机制，因此运行于多核DSP处理器上的操作系统多采用AMP架构。AMP架构也可应用于多核CPU上，以实现不同关键应用等级的隔离。  

锐华多核嵌入式操作系统基于分区架构，为了分别满足国产多核CPU处理器、国产多核DSP处理器，以及特定应用的要求，所研制的多核操作系统支持AMP、BMP、SMP三种多核架构处理方式，本文在已有成果的基础上设计多核确定性实时调度的确定性保障机制，以应用于锐华高安全操作系统研发设计中。

#### **资源静态配置**

与桌面系统不同，嵌入式操作系统通常使用静态配置的方式对资源进行配置。在操作系统初始化时，用户根据资源配置工具输入的数据（如任务数量、资源数量、定时器数量等），操作系统根据预定义规则，以生成的配置数据为输入，编译生成满足特定需求的嵌入式操作系统。对分区的配置包括分区时间调度表，分区所处的处理器核，分区物理起始地址和分区大小，分区中的线程数量、互斥信号量数量等，以保证分区的时空隔离特性，在一定程度上解决了系统资源和行为在调度过程中的不确定性问题。

#### **分区在多核上的分配部署**
多分区操作系统在多核上运行，核心是如何将不同的分区分配到各个处理器核上进行部署。对于SMP和AMP的不同架构，分区和核之间的分配关系也有所不同。  

（1）SMP架构  

采用SMP架构，一个分区能被分配在所有核上，并且在某个时刻独享资源。在一个分区内，任务可以在不同的核上并行执行。在该种架构下，由于分区间的执行是按照时间片轮流执行的，在下个分区开始运行前必须保存上一个分区的上下文，所以分区间不存在共享资源的干扰。但是，同一个分区内的不同任务间存在共享资源冲突，其示意图如图1所示。该种架构下，一个分区的故障不会蔓延到其他分区中，从而保证分区的健壮性。

![](../README.assets/Pasted%20image%2020240731195911.png)


（2）AMP架构  

AMP架构下，每个分区被分配在一个指定的核上，该分区内的所有任务都运行在该核上。不同的分区运行在不同的核上。不同的分区能够并行执行，但每个分区内的进程是顺序执行的，其示意图如图2所示。
![](../README.assets/Pasted%20image%2020240731195925.png)

本文所设计的新型多核分区架构使多核嵌入式操作系统同时支持SMP和AMP的应用，如图3所示。对于AMP应用，绑定在一个固定核上运行；对于SMP应用，可以在多个核上运行。分区内的任务只能在分区绑定的核上执行，不能在其他核上被调度。
![](../README.assets/Pasted%20image%2020240731195939.png)

#### **时间分区的设计与时间同步**
时间分区设计以ARINC653为标准，分区间优先级一样，以分区为调度的基本单位，分区在操作系统建立的主时间框架中占用至少一个时间窗口，分区间采用基于时间调度表的静态配置调度策略，每个处理器核维护一组调度表，根据系统预先配置选择一个调度表进行调度，默认情况下选择第一个调度表。时间调度表为一组时间窗口，每个时间窗口包括起始时间、持续时间、分区标识符等，并用双向链表方式来实现时间窗口。调度表的结构如图4所示。

![](../README.assets/Pasted%20image%2020240731200004.png)

为了保证不同处理器上的调度操作能够在时间上同步，采用一个全局的时钟源来同步各个处理器，并在每个时间框起始点对各个核的时间进行同步，确保本地调度表和全局时间的一致性来保证同步。本方案中采用本地时间驱动调度表，然后通知调度表全局时间，并保证本地时间和全局时间的偏差在一个可以接受的范围之内。调度表可以同步启动也可以异步启动。同步启动就是仅当本地时间和全局时间同步后调度表才会启动。异步启动不需要这种同步，可以通过两种方式进行重新同步：硬同步和平滑同步。所谓硬同步就是当得知全局时间后，在调度表结束时把本地时间设为全局时间，在调度表下次启动时获得同步。平滑同步就是在被告知全局时间后在每个调度点之间根据事先设定的量进行时间调整直到完成同步。  

从时间角度看分区间调度，其示意图如图5所示，分区一、三、四和七各自绑定在一个核上运行，而分二、五、六在多个核上运行。为了保障分区的健壮性和执行时间的确定性，结合考虑不同分区的关键等级，使得高安全关键等级分区可独占处理器，从而消除核间干扰。  

在分区内，任务调度可以采取基于固定优先级的抢占式调度保障确定性。通过这样的时间分区设计和时间同步使得任务调度在时间上是确定和可预测的。

![](../README.assets/Pasted%20image%2020240731200022.png)
### 总结
对于多核处理器上的安全关键应用，最大的挑战是多核干扰。本文设计的调度方案既可以像SMP一样在上层共享操作系统资源，又可以使用AMP用于核心事件的快速响应，这样的设计方法既保留了SMP方便易用、易于配置和负载均衡的能力，又实现AMP确定性和高性能等优点。同时时间分区的设计和时间同步使得安全性至关重要的应用程序行为是可预测的，进一步增强了多核操作系统的确定性、安全性、实时性和高效性。



## 基于微内核的嵌入式虚拟化技术
虚拟化是操作系统的一个重要技术，是嵌入式操作系统的发展一个重要的趋势。借助于对底层硬件：处理器内核、内存和外设的抽象，使得多个虚拟机OS可以运行在同一个物理处理器上。虚拟化提供了多操作系统的运行环境。

随着5G、物联网与集成电路技术的迅速发展，以及嵌入式设备的能力日益增强和广泛使用，嵌入式终端已成为云计算、物联网节点及大数据应用的重要元素。之前，被应用在PC、服务器端的虚拟化技术正逐渐渗透到嵌入式领域。  

早期，嵌入式虚拟化技术主要用于兼容不同操作系统的应用生态，降低各平台间的移植开销，提高应用的跨平台部署能力[1]。通过将多个操作系统合并到单一嵌入式平台上，来减少产品的成本、尺寸、重量和功率，清楚地分离关键和普通应用。近年来，为满足用户更多、更高的功能和安全需求，及面向异构硬件设备实现生态兼容，主流软、硬件厂商纷纷推出自己的嵌入式虚拟化产品，广泛应用到工业、医疗、航空、汽车、通信和能源等领域。

### **虚拟化概念**

虚拟化技术一般通过在操作系统和底层硬件之间增加一个虚拟化层来实现。虚拟化层在单一的硬件设备上虚拟出一个或多个运行环境，称为虚拟机（Virtual Ma-chine,VM），VM中运行的操作系统称为客户机（Guest OS），直接运行在真实物理机环境上的操作系统称为宿主操作系统（Host OS），而这个虚拟化层被称为虚拟机监视器 VMM（Virtual Machine Monitor）[2]。VMM 应具备的三个重要特征[3]：一致性、高效和资源受控，保证其可以有效地部署和实施。

### **完全虚拟化和半虚拟化**

虚拟化方式可以分为“全虚拟化”和“半虚拟化”两种[4]：半虚拟化不需要对底层硬件环境进行完全虚拟，但需要修改Guest OS，其性能可以接近在裸机上的性能，比全虚拟化更优越。全虚拟化提供底层物理系统的完全抽象化，通过降低对Guest OS的修改，实现更快、更灵活地更新Guest OS。

### VMM架构类型
VMM架构主要包括宿主架构（OS-Hosted VMM)、Hypervisor架构（Standalone Hypervisor VMM）和混合架构（Hybrid VMM）。具体架构如图1 所示。
![](../README.assets/Pasted%20image%2020240731201249.png)
（1）宿主架构（Type-II虚拟化）  

硬件资源完全由 Host OS管理，VMM作为一个应用程序运行在Host OS上，VMM上加载VM，优点是兼容性好，但需要调用Host OS的服务来实现虚拟化，效率低。  

（2）Hypervisor 架构（Type-I虚拟化）  

VMM直接运行在硬件上，完全管控硬件资源，向上层Guest OS提供虚拟化环境，优点是效率更高，但开发工作量大，兼容性差。  

（3）混合架构（Hybrid虚拟化）  

混合架构是前两种架构的综合，VMM直接运行在硬件上并拥有所有硬件资源，但会让出部分设备的控制权，移交给拥有特权的VM，优点是可以利用现有的硬件驱动，但在调用Service OS服务时，需要切换上下文，增加了系统开销。

### **嵌入式虚拟化**

面对构建基于嵌入式平台的兼容运行环境需求，传统嵌入式实时操作系统（Real Time Operating System,RTOS）及应用，由于其专为资源受限条件下设计和实时性等特点，很难支持其他平台的已有应用；主流通用操作系统平台又很难满足RTOS的实时性要求。

嵌入式虚拟化能够很好地解决这个问题，通过构建多个VM，实现不同类型操作系统的混合架构，VM的隔离也增强了系统安全性。但是，VM及系统资源完全由VMM管控，这对VMM安全性提出更高要求。与传统固定端不同，嵌入式 VMM必须具备高效率、高安全性、高效的通信机制、隔离和实时性等特点。


### **传统嵌入式虚拟化方案**

Hypervisor作为典型的嵌入式虚拟化架构，如图1所示。在半虚拟化方式下，需要对Guest OS源码进行修改，将敏感指令替换为 Hypervisor 提供的 Hypercall指令，当试图执行 Hypercall 时，保护异常就会触发，系统会陷入Hypervisor 去完成具体实现。主流 Hypervisor产品包括XEN、KVM等。  

XEN具体实现包括 Hypercall、事件机制、VM管控、内存管理等，架构详见图2。XEN采用较高特权级的VM （Domain0）管理其他 VM（DomainU），并可直接访问硬件资源。Domain0提供I/O虚拟化，DomainU的I/O事件虚拟和半虚拟化通过Domain0 与DomainU 之间的通信完成，通信基于XEN提供的事件通道来完成。Xen也实现了CPU和内存虚拟化，提供给 VM使用，其余通过Do-main0直接与硬件进行交互[5]。

![](../README.assets/Pasted%20image%2020240731201330.png)

虚拟化实现包括：  

①CPU虚拟化。通过将 VMM、Guest OS和应用运行在不同的异常级别（Exceptional Level,EL)，对系统各部分的访问权限进行了管控和保护。  

②内存虚拟化。采用两个阶段地址转换，Guest OS 使用虚拟地址（VA），通过页表将VA 转换为中间物理地址（IPA）完成第一阶段的转换；再由 VMM使用第二阶段页表将IPA转换为物理地址（PA），第二阶段地址转换过程及页表对Guest OS是不可见的。  

③I/O虚拟化。支持虚拟异常和中断在 VM 之间的分发，物理异常被配置为VMM捕获，虚拟异常则被分发注入到Guest OS。DomainU 通过虚拟设备接口访问Domain0，并由Domain0提供具体实现。

### **微内核与嵌入式虚拟化**

微内核架构具有的高安全、高可靠，高灵活性、实时性支持和可进行高等级安全认证等特点，使基于微内核虚拟化的新体系架构逐渐得到更广泛的应用。

\微内核可以被看作是对传统操作系统共性的进一步抽象，这种抽象使得内核只提供机制，而把实现策略留给提供具体服务的服务组件。  

微内核应提供三个关键抽象：address space,threads 和 inter- process communication（IPC）；其他部分（如文件系统、设备驱动等）都以服务的形式运行在用户态，不能直接访问底层硬件设备，服务间相互隔离必须通过微内核提供的IPC进行通信。通过对IPC机制进行优化，微内核IPC速度已经得到有效的提升。测试表明，运行的L4之上 Linux 比宏内核只慢大约5%~10%。  

微内核突出的优点是代码规模小，容易进行形式化验证。如sel4微内核只有约1万行，而完全的形式化认证是确保系统不会出现编程和设计错误的唯一方法。主流微内核产品（如 Sel4、PikeOS 和VxWorks等）都通过形式化验证来证明产品的安全可靠。  

一般将VMM拆分为拥有更高特权级Microkernel和Monitor两个部分，系统架构见图3。底层为Microkernel 直接运行在硬件层上提供对上层VM的支持；上层为运行在用户态模式下的服务组件、VMM、VM，与底层微内核共同维护提供给应用层的虚拟化环境。

![](../README.assets/Pasted%20image%2020240731201402.png)

具体实现包括：①修改Guest OS，包括内核调用接口、内存管理和中断处理等部分，以适配微内核提供的系统调用接口。②VMM负责对VM管理和维护，管控VM 对真实系统资源的访问，实现VM的安全隔离；维护VM 的虚拟化运行环境，通过调用上层运行在用户态模式下的服务组件为VM提供具体的系统服务实现。③Microker-nel负责为上层 VM、VMM、系统服务组件和应用提供具体的执行环境，提供对VM透明、完整的中断响应机制及实现。


### **微内核虚拟机监视器**

Microkernel与Hypervisor都拥有相对较高的特权级、直接运行在硬件上、提供对硬件的并发访问和隔离机制等共性，这为两者结合提供天然优势。Microkernel Hypervi-sor集成了这两者的特点，是具有虚拟化功能的微内核。  

Microkernel Hypervisor 不是将 Microkernel和 hypervisor 简单的结合。其中，微内核架构不能影响其他服务的功能及质量，必须最小化对微内核的修改，利用其原有的核心功能和运行机制，基于微内核原语来实现 VM 的虚拟化。  

在L4微内核的虚拟化实现中，采用半虚拟化改造的L4 Linux作为Guest OS，用户程序与L4 Linux相互隔离，实现了客户机／服务器（Client/Server,C/S）架构，L4 Linux作为Server提供内核服务。[6]非可信的用户程序作为Client，只能通过IPC同Server进行通信并请求内核服务。在这种模式下，需要对系统调用重定向到Server，由L4 Linux实现具体的功能并返回结果。  

具体实现包括[7]：①VM的VCPU具体由L4线程来负责虚拟实现，该线程由L4负责管理，基于时间片和优先级进行调度。②LA微内核把硬件中断处理成 IPC消息。当一个硬件中断发生时，微内核会为这个中断产生一条消息，并把此消息发送到与此中断相关联的用户进程中。  

基于微内核的虚拟化方案的代表产品有Sel4、OKL4、INTEGRITY Multivisor 和 QNX Hypervisor等。

- **Sel4**

Sel4作为L4家族的第三代微内核，架构如图4所示。Sel4 的Guest OS支持包括 Linux等主流操作系统。应用程序既可以调用VM提供的系统服务，也可以调用直接运行在Sel4 上的Native服务组件，实现具体系统功能。Sel4 运行在较高的特权级的Hypervisor模式下，负责完成很少的工作，其余部分由上层运行在较低特权级用户态模式下的Native应用、服务和 VM来完成。Sel4负责管理上层VM，捕获虚拟异常并分发给用户层的VMM进行处理，具体的虚拟化操作由 VMM 负责完成。
![](../README.assets/Pasted%20image%2020240731201557.png)


- **OKL4**

OKL4的microvisor是基于原L4设计实现的半虚拟化 Hypervisor，运行在核心态；采用名为安全单元的分区对VM进行分区，其余所有VM、原生应用和驱动程序都被推到单独的隔离分区中运行在用户态模式下，各单元只能通过 microvisor提供的IPC机制进行通信和协作。microvisor采用轻量级的组件模型，应用和驱动程序可以单独集成到没有操作系统的分区中。microvisor 提供快速IPC消息传递机制和共享内存。Motorola Evoke QA4 就基于FASS共享内存机制实现了 Linux 和 BREW 虚拟机之间共享 Frame Buffer来提高图形性能[8]。

- **INTEGRITY Multivisor**

INTEGRITY Multivisor 是 Green Hills公司推出的虚拟化基础框架，支持半虚拟化和完全虚拟化，支持多种处理器。Multivisor负责为上层VM分配和管理设备，VM可以共享或直接分配设备，为Guest OS及关键应用间提供高效IPC通信；为Guest OS配置包括内存和设备等系统资源；提供针对VM的硬件辅助虚拟化支持、安全管理、故障检测，以及VM和应用的重启等功能。Multivisor支持多核处理器版本，在AMP模型下可以将Guest OS静态地绑定到各个CPU核上；而在SMP模型下又可以动态地调度工作负载。


- **QNX Hypervisor**

QNX Hypervisor是实时Type-I 类型的Microkernel Hypervisor，支持多个64位和32位Guest OS（如 QNX、Linux、Android、RTOS等），提供包括CPU、内存和外设的虚拟化，以及基于VM的终端隔离，既可为VM配置和管理虚拟设备和VCPU，将VCPU、VM绑定到具体的CPU 核和物理设备；又可以基于优先级调度和行业标准虚拟驱动接口支持，实现多个VCPU共享CPU核和物理设备共享，支持VM的动态关闭和重启。QNX Hypervisor采用了简洁技术，共享整个系统的通用元素，包括显示控制器、网络连接、文件系统及I2C串行总线等其他输入／输出设备，这可以节约成本，提高运行效率。通过支持包括共享内存、共享文件和高速TCP/IP/UDP等高效通信方式，实现应用和VM间的协同。

随着硬件性能的提升，在嵌入式领域中呈现出在一台设备上运行混合关键性（mixed-criticality）任务的行业趋势。critical的软件需要与non-critical的软件一起运行在同一设备成为越来越普遍的现象，如汽车电子、航空电子等系统中驾驶控制（critical）和娱乐软件（non-critical）并存。微内核架构的 Hypervisor 由于其代码规模小，可形式化验证，在安全性、可靠性、灵活性等方面具有优势，成为实现嵌入式虚拟化的重要技术，将在混合关键系统中得到广泛应用。